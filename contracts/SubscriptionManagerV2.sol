// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "./SmartWallet.sol";

/**
 * @title SubscriptionManagerV2
 * @dev Enhanced gasless subscription manager with multi-token support and configurable billing
 * @notice Supports multiple ERC20 tokens, flexible billing frequencies, and third-party integrations
 */
contract SubscriptionManagerV2 is Ownable, ReentrancyGuard, Pausable {
    using SafeERC20 for IERC20;

    // Billing frequency options
    enum BillingFrequency {
        DAILY,      // 24 hours
        WEEKLY,     // 7 days
        MONTHLY,    // 30 days
        QUARTERLY,  // 90 days
        YEARLY,     // 365 days
        CUSTOM      // Custom interval in seconds
    }

    // Enhanced subscription plan structure
    struct SubscriptionPlan {
        uint256 planId;
        string name;
        string description;
        address paymentToken;
        uint256 price;
        BillingFrequency billingFrequency;
        uint256 customInterval; // Used when billingFrequency is CUSTOM
        uint256 maxSubscriptions; // 0 for unlimited
        uint256 currentSubscriptions;
        bool isActive;
        address beneficiary; // who receives the payments
        uint256 trialPeriod; // Trial period in seconds (0 for no trial)
        uint256 createdAt;
        uint256 totalRevenue; // Total revenue generated by this plan
        // Analytics fields
        uint256 totalSubscribers; // All-time subscriber count
        uint256 churnCount; // Number of cancellations
    }

    // Enhanced user subscription structure
    struct UserSubscription {
        uint256 subscriptionId;
        uint256 planId;
        address subscriber; // SmartWallet address
        address owner; // actual user who owns the SmartWallet
        uint256 startTime;
        uint256 trialEndTime; // 0 if no trial
        uint256 nextBillingTime;
        uint256 lastChargedTime;
        uint256 totalPayments;
        uint256 totalAmountPaid;
        bool isActive;
        bool autoRenew;
        bool isTrialActive;
        string metadata; // JSON metadata for additional plan info
    }

    // Supported token information
    struct TokenInfo {
        bool isSupported;
        uint8 decimals;
        string symbol;
        uint256 minAmount; // Minimum subscription amount for this token
        bool requiresApproval; // Whether token requires pre-approval
    }

    // State variables
    mapping(uint256 => SubscriptionPlan) public subscriptionPlans;
    mapping(uint256 => UserSubscription) public userSubscriptions;
    mapping(address => uint256[]) public userSubscriptionIds;
    mapping(uint256 => uint256[]) public planSubscriptionIds;
    mapping(address => bool) public authorizedRelayers;
    mapping(address => bool) public automationKeepers; // Gelato/Chainlink keepers
    mapping(address => TokenInfo) public supportedTokens;
    
    uint256 public nextPlanId;
    uint256 public nextSubscriptionId;
    uint256 public maxBatchSize = 50;
    uint256 public gracePeriod = 7 days; // Grace period for failed payments
    uint256 public platformFeePercentage = 250; // 2.5% platform fee (basis points)
    address public platformFeeRecipient;

    // Analytics tracking
    uint256 public totalRevenue;
    uint256 public totalActiveSubscriptions;
    uint256 public totalLifetimeSubscriptions;

    // Events with enhanced token information
    event PlanCreated(
        uint256 indexed planId,
        string name,
        address indexed paymentToken,
        uint256 price,
        BillingFrequency billingFrequency,
        address indexed beneficiary,
        uint256 trialPeriod
    );

    event Subscribed(
        uint256 indexed subscriptionId,
        uint256 indexed planId,
        address indexed subscriber,
        address owner,
        address paymentToken,
        uint256 amount,
        uint256 timestamp,
        bool isTrialActive
    );

    event Charged(
        uint256 indexed subscriptionId,
        address indexed subscriber,
        address indexed paymentToken,
        uint256 amount,
        uint256 platformFee,
        uint256 timestamp,
        uint256 totalPayments
    );

    event Unsubscribed(
        uint256 indexed subscriptionId,
        address indexed subscriber,
        address paymentToken,
        uint256 timestamp,
        string reason,
        uint256 totalAmountPaid
    );

    event TokenSupported(address indexed token, uint8 decimals, string symbol, uint256 minAmount);
    event TokenUnsupported(address indexed token);
    event PlanUpdated(uint256 indexed planId, bool isActive);
    event RelayerAuthorized(address indexed relayer, bool authorized);
    event KeeperAuthorized(address indexed keeper, bool authorized);
    event PlatformFeeUpdated(uint256 newFeePercentage, address newRecipient);
    event TrialStarted(uint256 indexed subscriptionId, uint256 trialEndTime);
    event TrialEnded(uint256 indexed subscriptionId, bool converted);

    modifier onlyAuthorizedRelayer() {
        require(authorizedRelayers[msg.sender] || msg.sender == owner(), "SubscriptionManagerV2: unauthorized relayer");
        _;
    }

    modifier onlyAuthorizedKeeper() {
        require(automationKeepers[msg.sender] || msg.sender == owner(), "SubscriptionManagerV2: unauthorized keeper");
        _;
    }

    modifier validPlan(uint256 planId) {
        require(planId < nextPlanId, "SubscriptionManagerV2: invalid plan ID");
        require(subscriptionPlans[planId].isActive, "SubscriptionManagerV2: plan not active");
        _;
    }

    modifier validSubscription(uint256 subscriptionId) {
        require(subscriptionId < nextSubscriptionId, "SubscriptionManagerV2: invalid subscription ID");
        _;
    }

    modifier supportedToken(address token) {
        require(supportedTokens[token].isSupported, "SubscriptionManagerV2: token not supported");
        _;
    }

    constructor(address _platformFeeRecipient) {
        require(_platformFeeRecipient != address(0), "SubscriptionManagerV2: invalid fee recipient");
        platformFeeRecipient = _platformFeeRecipient;
        _transferOwnership(msg.sender);
    }

    /**
     * @dev Add support for a new ERC20 token
     * @param token Token contract address
     * @param decimals Token decimals
     * @param symbol Token symbol
     * @param minAmount Minimum subscription amount for this token
     * @param requiresApproval Whether token requires pre-approval
     */
    function addSupportedToken(
        address token,
        uint8 decimals,
        string calldata symbol,
        uint256 minAmount,
        bool requiresApproval
    ) external onlyOwner {
        require(token != address(0), "SubscriptionManagerV2: invalid token");
        require(bytes(symbol).length > 0, "SubscriptionManagerV2: invalid symbol");
        
        supportedTokens[token] = TokenInfo({
            isSupported: true,
            decimals: decimals,
            symbol: symbol,
            minAmount: minAmount,
            requiresApproval: requiresApproval
        });
        
        emit TokenSupported(token, decimals, symbol, minAmount);
    }

    /**
     * @dev Remove support for a token
     * @param token Token contract address
     */
    function removeSupportedToken(address token) external onlyOwner {
        require(supportedTokens[token].isSupported, "SubscriptionManagerV2: token not supported");
        delete supportedTokens[token];
        emit TokenUnsupported(token);
    }

    /**
     * @dev Get billing interval in seconds based on frequency
     * @param frequency Billing frequency enum
     * @param customInterval Custom interval for CUSTOM frequency
     */
    function getBillingInterval(BillingFrequency frequency, uint256 customInterval) public pure returns (uint256) {
        if (frequency == BillingFrequency.DAILY) return 1 days;
        if (frequency == BillingFrequency.WEEKLY) return 7 days;
        if (frequency == BillingFrequency.MONTHLY) return 30 days;
        if (frequency == BillingFrequency.QUARTERLY) return 90 days;
        if (frequency == BillingFrequency.YEARLY) return 365 days;
        if (frequency == BillingFrequency.CUSTOM) {
            require(customInterval > 0, "SubscriptionManagerV2: invalid custom interval");
            return customInterval;
        }
        revert("SubscriptionManagerV2: invalid billing frequency");
    }

    /**
     * @dev Create an enhanced subscription plan with multi-token support
     * @param name Plan name
     * @param description Plan description
     * @param paymentToken Token address for payments
     * @param price Price per billing cycle
     * @param billingFrequency Billing frequency
     * @param customInterval Custom interval for CUSTOM frequency
     * @param maxSubscriptions Maximum number of subscriptions (0 for unlimited)
     * @param beneficiary Address that receives payments
     * @param trialPeriod Trial period in seconds (0 for no trial)
     * @param metadata JSON metadata string
     */
    function createPlan(
        string calldata name,
        string calldata description,
        address paymentToken,
        uint256 price,
        BillingFrequency billingFrequency,
        uint256 customInterval,
        uint256 maxSubscriptions,
        address beneficiary,
        uint256 trialPeriod,
        string calldata metadata
    ) external onlyOwner supportedToken(paymentToken) returns (uint256 planId) {
        require(bytes(name).length > 0, "SubscriptionManagerV2: invalid name");
        require(price >= supportedTokens[paymentToken].minAmount, "SubscriptionManagerV2: price below minimum");
        require(beneficiary != address(0), "SubscriptionManagerV2: invalid beneficiary");

        uint256 billingInterval = getBillingInterval(billingFrequency, customInterval);

        planId = nextPlanId++;
        
        subscriptionPlans[planId] = SubscriptionPlan({
            planId: planId,
            name: name,
            description: description,
            paymentToken: paymentToken,
            price: price,
            billingFrequency: billingFrequency,
            customInterval: customInterval,
            maxSubscriptions: maxSubscriptions,
            currentSubscriptions: 0,
            isActive: true,
            beneficiary: beneficiary,
            trialPeriod: trialPeriod,
            createdAt: block.timestamp,
            totalRevenue: 0,
            totalSubscribers: 0,
            churnCount: 0
        });

        emit PlanCreated(planId, name, paymentToken, price, billingFrequency, beneficiary, trialPeriod);
    }

    /**
     * @dev Subscribe to a plan with enhanced features (gasless for user)
     * @param planId Plan ID to subscribe to
     * @param smartWallet User's SmartWallet address
     * @param owner Actual owner of the SmartWallet
     * @param autoRenew Whether to auto-renew the subscription
     * @param metadata Additional subscription metadata
     */
    function subscribe(
        uint256 planId,
        address smartWallet,
        address owner,
        bool autoRenew,
        string calldata metadata
    ) external onlyAuthorizedRelayer validPlan(planId) whenNotPaused returns (uint256 subscriptionId) {
        SubscriptionPlan storage plan = subscriptionPlans[planId];
        
        // Check max subscriptions limit
        if (plan.maxSubscriptions > 0) {
            require(
                plan.currentSubscriptions < plan.maxSubscriptions,
                "SubscriptionManagerV2: max subscriptions reached"
            );
        }

        // Verify SmartWallet ownership
        require(SmartWallet(payable(smartWallet)).owner() == owner, "SubscriptionManagerV2: invalid wallet owner");

        // Check token approval if required
        if (supportedTokens[plan.paymentToken].requiresApproval) {
            uint256 approval = SmartWallet(payable(smartWallet)).getSubscriptionApproval(
                plan.paymentToken,
                address(this)
            );
            require(approval >= plan.price, "SubscriptionManagerV2: insufficient approval");
        }

        subscriptionId = nextSubscriptionId++;
        
        uint256 billingInterval = getBillingInterval(plan.billingFrequency, plan.customInterval);
        bool isTrialActive = plan.trialPeriod > 0;
        uint256 trialEndTime = isTrialActive ? block.timestamp + plan.trialPeriod : 0;
        uint256 nextBilling = isTrialActive ? trialEndTime : block.timestamp + billingInterval;
        
        userSubscriptions[subscriptionId] = UserSubscription({
            subscriptionId: subscriptionId,
            planId: planId,
            subscriber: smartWallet,
            owner: owner,
            startTime: block.timestamp,
            trialEndTime: trialEndTime,
            nextBillingTime: nextBilling,
            lastChargedTime: 0,
            totalPayments: 0,
            totalAmountPaid: 0,
            isActive: true,
            autoRenew: autoRenew,
            isTrialActive: isTrialActive,
            metadata: metadata
        });

        // Update plan statistics
        plan.currentSubscriptions++;
        plan.totalSubscribers++;
        
        // Update global statistics
        totalActiveSubscriptions++;
        totalLifetimeSubscriptions++;
        
        // Track user subscriptions
        userSubscriptionIds[smartWallet].push(subscriptionId);
        planSubscriptionIds[planId].push(subscriptionId);

        emit Subscribed(
            subscriptionId, 
            planId, 
            smartWallet, 
            owner, 
            plan.paymentToken,
            plan.price,
            block.timestamp,
            isTrialActive
        );

        if (isTrialActive) {
            emit TrialStarted(subscriptionId, trialEndTime);
        }
    }

    /**
     * @dev Enhanced charge subscriber with multi-token support
     * @param subscriptionId Subscription ID to charge
     */
    function chargeSubscriber(
        uint256 subscriptionId
    ) external onlyAuthorizedKeeper nonReentrant validSubscription(subscriptionId) whenNotPaused {
        UserSubscription storage subscription = userSubscriptions[subscriptionId];
        require(subscription.isActive, "SubscriptionManagerV2: subscription not active");
        require(
            block.timestamp >= subscription.nextBillingTime,
            "SubscriptionManagerV2: billing not due"
        );

        SubscriptionPlan storage plan = subscriptionPlans[subscription.planId];
        require(plan.isActive, "SubscriptionManagerV2: plan not active");

        // Handle trial period end
        if (subscription.isTrialActive && block.timestamp >= subscription.trialEndTime) {
            subscription.isTrialActive = false;
            emit TrialEnded(subscriptionId, true); // Converted to paid
        }

        SmartWallet wallet = SmartWallet(payable(subscription.subscriber));
        
        // Check if wallet has sufficient approval
        uint256 approval = wallet.getSubscriptionApproval(plan.paymentToken, address(this));
        if (approval < plan.price) {
            _handleFailedPayment(subscriptionId, "insufficient approval");
            return;
        }

        // Check if wallet has sufficient balance
        IERC20 token = IERC20(plan.paymentToken);
        uint256 balance = token.balanceOf(subscription.subscriber);
        if (balance < plan.price) {
            _handleFailedPayment(subscriptionId, "insufficient balance");
            return;
        }

        // Calculate platform fee
        uint256 platformFee = (plan.price * platformFeePercentage) / 10000;
        uint256 beneficiaryAmount = plan.price - platformFee;

        try wallet.executeSubscriptionPayment(plan.paymentToken, plan.beneficiary, beneficiaryAmount) {
            // Transfer platform fee if any
            if (platformFee > 0) {
                wallet.executeSubscriptionPayment(plan.paymentToken, platformFeeRecipient, platformFee);
            }

            // Update subscription
            subscription.lastChargedTime = block.timestamp;
            uint256 billingInterval = getBillingInterval(plan.billingFrequency, plan.customInterval);
            subscription.nextBillingTime = block.timestamp + billingInterval;
            subscription.totalPayments++;
            subscription.totalAmountPaid += plan.price;

            // Update plan revenue
            plan.totalRevenue += plan.price;
            
            // Update global revenue
            totalRevenue += plan.price;

            emit Charged(
                subscriptionId, 
                subscription.subscriber, 
                plan.paymentToken,
                plan.price, 
                platformFee, 
                block.timestamp,
                subscription.totalPayments
            );
        } catch {
            _handleFailedPayment(subscriptionId, "transfer failed");
        }
    }

    /**
     * @dev Enhanced unsubscribe with analytics tracking
     * @param subscriptionId Subscription ID to cancel
     * @param reason Reason for unsubscribing
     */
    function unsubscribe(uint256 subscriptionId, string calldata reason) external validSubscription(subscriptionId) {
        UserSubscription storage subscription = userSubscriptions[subscriptionId];
        require(subscription.isActive, "SubscriptionManagerV2: already inactive");
        
        // Allow unsubscribe by owner of the SmartWallet or authorized relayer
        require(
            SmartWallet(payable(subscription.subscriber)).owner() == msg.sender ||
            authorizedRelayers[msg.sender] ||
            msg.sender == owner(),
            "SubscriptionManagerV2: unauthorized"
        );

        SubscriptionPlan storage plan = subscriptionPlans[subscription.planId];
        
        subscription.isActive = false;
        
        // Update statistics
        plan.currentSubscriptions--;
        plan.churnCount++;
        totalActiveSubscriptions--;

        // Handle trial cancellation
        if (subscription.isTrialActive) {
            emit TrialEnded(subscriptionId, false); // Not converted
        }

        emit Unsubscribed(
            subscriptionId, 
            subscription.subscriber, 
            plan.paymentToken,
            block.timestamp, 
            reason,
            subscription.totalAmountPaid
        );
    }

    // ... (Additional functions for batch operations, analytics, etc. continue in next part)

    /**
     * @dev Batch charge multiple subscribers with enhanced tracking
     * @param subscriptionIds Array of subscription IDs to charge
     */
    function batchChargeSubscribers(
        uint256[] calldata subscriptionIds
    ) external onlyAuthorizedKeeper nonReentrant whenNotPaused {
        require(subscriptionIds.length <= maxBatchSize, "SubscriptionManagerV2: batch too large");

        for (uint256 i = 0; i < subscriptionIds.length; i++) {
            if (subscriptionIds[i] < nextSubscriptionId) {
                UserSubscription storage subscription = userSubscriptions[subscriptionIds[i]];
                
                if (subscription.isActive && 
                    block.timestamp >= subscription.nextBillingTime &&
                    subscriptionPlans[subscription.planId].isActive) {
                    
                    _chargeSubscriberInternal(subscriptionIds[i]);
                }
            }
        }
    }

    /**
     * @dev Get enhanced subscription analytics for a plan
     * @param planId Plan ID
     */
    function getPlanAnalytics(uint256 planId) external view returns (
        uint256 totalSubscribers,
        uint256 activeSubscribers,
        uint256 totalRevenue,
        uint256 churnCount,
        uint256 churnRate // in basis points
    ) {
        require(planId < nextPlanId, "SubscriptionManagerV2: invalid plan ID");
        SubscriptionPlan storage plan = subscriptionPlans[planId];
        
        totalSubscribers = plan.totalSubscribers;
        activeSubscribers = plan.currentSubscriptions;
        totalRevenue = plan.totalRevenue;
        churnCount = plan.churnCount;
        
        // Calculate churn rate (churn / total * 10000 for basis points)
        churnRate = totalSubscribers > 0 ? (churnCount * 10000) / totalSubscribers : 0;
    }

    /**
     * @dev Get global analytics
     */
    function getGlobalAnalytics() external view returns (
        uint256 _totalRevenue,
        uint256 _totalActiveSubscriptions,
        uint256 _totalLifetimeSubscriptions,
        uint256 _totalPlans
    ) {
        return (totalRevenue, totalActiveSubscriptions, totalLifetimeSubscriptions, nextPlanId);
    }

    /**
     * @dev Get subscriptions due for billing (enhanced)
     * @param limit Maximum number of subscriptions to return
     * @param tokenFilter Filter by specific token (address(0) for all tokens)
     */
    function getSubscriptionsDue(
        uint256 limit,
        address tokenFilter
    ) external view returns (uint256[] memory) {
        uint256[] memory dueSubscriptions = new uint256[](limit);
        uint256 count = 0;
        
        for (uint256 i = 0; i < nextSubscriptionId && count < limit; i++) {
            UserSubscription storage subscription = userSubscriptions[i];
            SubscriptionPlan storage plan = subscriptionPlans[subscription.planId];
            
            bool tokenMatch = tokenFilter == address(0) || plan.paymentToken == tokenFilter;
            
            if (subscription.isActive && 
                block.timestamp >= subscription.nextBillingTime &&
                plan.isActive &&
                tokenMatch) {
                dueSubscriptions[count] = i;
                count++;
            }
        }
        
        // Resize array to actual count
        uint256[] memory result = new uint256[](count);
        for (uint256 i = 0; i < count; i++) {
            result[i] = dueSubscriptions[i];
        }
        
        return result;
    }

    /**
     * @dev Get user subscription details with enhanced info
     * @param user User's SmartWallet address
     */
    function getUserSubscriptionDetails(address user) external view returns (
        uint256[] memory subscriptionIds,
        uint256[] memory planIds,
        address[] memory tokens,
        uint256[] memory amounts,
        bool[] memory activeStatus,
        uint256[] memory nextBillingTimes
    ) {
        uint256[] storage userSubs = userSubscriptionIds[user];
        uint256 length = userSubs.length;
        
        subscriptionIds = new uint256[](length);
        planIds = new uint256[](length);
        tokens = new address[](length);
        amounts = new uint256[](length);
        activeStatus = new bool[](length);
        nextBillingTimes = new uint256[](length);
        
        for (uint256 i = 0; i < length; i++) {
            uint256 subId = userSubs[i];
            UserSubscription storage sub = userSubscriptions[subId];
            SubscriptionPlan storage plan = subscriptionPlans[sub.planId];
            
            subscriptionIds[i] = subId;
            planIds[i] = sub.planId;
            tokens[i] = plan.paymentToken;
            amounts[i] = plan.price;
            activeStatus[i] = sub.isActive;
            nextBillingTimes[i] = sub.nextBillingTime;
        }
    }

    /**
     * @dev Authorize automation keeper (Gelato/Chainlink)
     * @param keeper Keeper address
     * @param authorized Whether to authorize or revoke
     */
    function setKeeperAuthorization(address keeper, bool authorized) external onlyOwner {
        automationKeepers[keeper] = authorized;
        emit KeeperAuthorized(keeper, authorized);
    }

    /**
     * @dev Authorize relayer for gasless transactions
     * @param relayer Relayer address
     * @param authorized Whether to authorize or revoke
     */
    function setRelayerAuthorization(address relayer, bool authorized) external onlyOwner {
        authorizedRelayers[relayer] = authorized;
        emit RelayerAuthorized(relayer, authorized);
    }

    /**
     * @dev Update platform fee
     * @param newFeePercentage New fee percentage (basis points)
     * @param newRecipient New fee recipient
     */
    function updatePlatformFee(uint256 newFeePercentage, address newRecipient) external onlyOwner {
        require(newFeePercentage <= 1000, "SubscriptionManagerV2: fee too high"); // Max 10%
        require(newRecipient != address(0), "SubscriptionManagerV2: invalid recipient");
        
        platformFeePercentage = newFeePercentage;
        platformFeeRecipient = newRecipient;
        
        emit PlatformFeeUpdated(newFeePercentage, newRecipient);
    }

    /**
     * @dev Update plan status
     * @param planId Plan ID
     * @param isActive New status
     */
    function updatePlanStatus(uint256 planId, bool isActive) external onlyOwner {
        require(planId < nextPlanId, "SubscriptionManagerV2: invalid plan ID");
        subscriptionPlans[planId].isActive = isActive;
        emit PlanUpdated(planId, isActive);
    }

    /**
     * @dev Set maximum batch size for operations
     * @param newMaxBatchSize New maximum batch size
     */
    function setMaxBatchSize(uint256 newMaxBatchSize) external onlyOwner {
        require(newMaxBatchSize > 0, "SubscriptionManagerV2: invalid batch size");
        maxBatchSize = newMaxBatchSize;
    }

    /**
     * @dev Pause the contract
     */
    function pause() external onlyOwner {
        _pause();
    }

    /**
     * @dev Unpause the contract
     */
    function unpause() external onlyOwner {
        _unpause();
    }

    /**
     * @dev Get subscription details
     * @param subscriptionId Subscription ID
     */
    function getSubscription(uint256 subscriptionId) external view validSubscription(subscriptionId) returns (UserSubscription memory) {
        return userSubscriptions[subscriptionId];
    }

    /**
     * @dev Get subscription plan details
     * @param planId Plan ID
     */
    function getPlan(uint256 planId) external view returns (SubscriptionPlan memory) {
        require(planId < nextPlanId, "SubscriptionManagerV2: invalid plan ID");
        return subscriptionPlans[planId];
    }

    /**
     * @dev Get user's subscription IDs
     * @param user User's SmartWallet address
     */
    function getUserSubscriptions(address user) external view returns (uint256[] memory) {
        return userSubscriptionIds[user];
    }

    /**
     * @dev Get subscriptions for a plan
     * @param planId Plan ID
     */
    function getPlanSubscriptions(uint256 planId) external view returns (uint256[] memory) {
        return planSubscriptionIds[planId];
    }

    /**
     * @dev Check if token is supported
     * @param token Token address
     */
    function isTokenSupported(address token) external view returns (bool) {
        return supportedTokens[token].isSupported;
    }

    /**
     * @dev Get supported token info
     * @param token Token address
     */
    function getTokenInfo(address token) external view returns (TokenInfo memory) {
        return supportedTokens[token];
    }

    /**
     * @dev Internal function to charge a subscriber (without reentrancy guard)
     * @param subscriptionId Subscription ID
     */
    function _chargeSubscriberInternal(uint256 subscriptionId) internal {
        UserSubscription storage subscription = userSubscriptions[subscriptionId];
        SubscriptionPlan storage plan = subscriptionPlans[subscription.planId];

        // Handle trial period end
        if (subscription.isTrialActive && block.timestamp >= subscription.trialEndTime) {
            subscription.isTrialActive = false;
            emit TrialEnded(subscriptionId, true);
        }

        SmartWallet wallet = SmartWallet(payable(subscription.subscriber));
        
        // Check approval and balance
        uint256 approval = wallet.getSubscriptionApproval(plan.paymentToken, address(this));
        IERC20 token = IERC20(plan.paymentToken);
        uint256 balance = token.balanceOf(subscription.subscriber);
        
        if (approval < plan.price || balance < plan.price) {
            _handleFailedPayment(subscriptionId, approval < plan.price ? "insufficient approval" : "insufficient balance");
            return;
        }

        // Calculate platform fee
        uint256 platformFee = (plan.price * platformFeePercentage) / 10000;
        uint256 beneficiaryAmount = plan.price - platformFee;

        try wallet.executeSubscriptionPayment(plan.paymentToken, plan.beneficiary, beneficiaryAmount) {
            // Transfer platform fee if any
            if (platformFee > 0) {
                wallet.executeSubscriptionPayment(plan.paymentToken, platformFeeRecipient, platformFee);
            }

            // Update subscription
            subscription.lastChargedTime = block.timestamp;
            uint256 billingInterval = getBillingInterval(plan.billingFrequency, plan.customInterval);
            subscription.nextBillingTime = block.timestamp + billingInterval;
            subscription.totalPayments++;
            subscription.totalAmountPaid += plan.price;

            // Update plan revenue
            plan.totalRevenue += plan.price;
            totalRevenue += plan.price;

            emit Charged(
                subscriptionId, 
                subscription.subscriber, 
                plan.paymentToken,
                plan.price, 
                platformFee, 
                block.timestamp,
                subscription.totalPayments
            );
        } catch {
            _handleFailedPayment(subscriptionId, "transfer failed");
        }
    }

    /**
     * @dev Handle failed payment with enhanced tracking
     * @param subscriptionId Subscription ID
     * @param reason Failure reason
     */
    function _handleFailedPayment(uint256 subscriptionId, string memory reason) internal {
        UserSubscription storage subscription = userSubscriptions[subscriptionId];
        SubscriptionPlan storage plan = subscriptionPlans[subscription.planId];
        
        // If grace period has passed, cancel subscription
        if (block.timestamp >= subscription.nextBillingTime + gracePeriod) {
            subscription.isActive = false;
            plan.currentSubscriptions--;
            plan.churnCount++;
            totalActiveSubscriptions--;
            
            emit Unsubscribed(
                subscriptionId, 
                subscription.subscriber, 
                plan.paymentToken,
                block.timestamp, 
                reason,
                subscription.totalAmountPaid
            );
        }
        // Otherwise, extend next billing time by 1 day for retry
        else {
            subscription.nextBillingTime = block.timestamp + 1 days;
        }
    }
}